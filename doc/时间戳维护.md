# 计算盘口价格到交易所之间的延迟
1、
{
  "u":400900217,     // order book updateId
  "s":"BNBUSDT",     // 交易对
  "b":"25.35190000", // 买单最优挂单价格
  "B":"31.21000000", // 买单最优挂单数量
  "a":"25.36520000", // 卖单最优挂单价格
  "A":"40.66000000"  // 卖单最优挂单数量
}
盘口数据无法获取时间戳，只有u，无法判断u到本地的时间戳

2、
100ms一个的信息，可以知道u = 160 对应的交易所时间 E
{
  "e": "depthUpdate", // 事件类型
  "E": 1672515782136, // 事件时间
  "s": "BNBBTC",      // 交易对
  "U": 157,           // 从上次推送至今新增的第一个 update Id
  "u": 160,           // 从上次推送至今新增的最后一个 update Id
  "b": [              // 变动的买单深度
    [
      "0.0024",       // 价
      "10",           // 量
      []              // Ignore
    ]
  ],
  "a": [              // 变动的卖单深度
    [
      "0.0026",       // 价
      "100",          // 量
      []              // Ignore
    ]
  ]
}

3、本质上，延迟数据是盘后用的，只需要一个估计值。u可以推算盘口时间。查找对应的u然后进行前向填充就可以获得交易所时间，然后本地时间直接用时间戳打印

使用GJSON来做parser

维护一个coin list，之后可能考虑跨所，所以对于一个币，映射一个固定的index，写死配置文件，通过一个csv文件维护index和币对 col行号就是对应的索引

websocket为了保证行情的稳定性，double维护行情，每个行情建立两个websocket连接，间断重启，否则中间有行情中断。

对于币安，

okex有depth的高频数据，10s一次

bybit要订阅的数据和现在是一样的，完全一致。只是要订阅双路来保证数据的完整性。

ws要考虑重启

维护最优盘口的方式: 每个index映射一个struct ask1 bid1 askv1 bidv1 ts， 对于币安是id。ts后补

tip 需要维护一个本地的校准时钟
1、初期直接用rust的instant
2、后期改为（CPU固定 + RDTSC）的本地时钟算法

这是一般的延迟数据。

为了观测交易的整体延迟，需要分为触发价差的数据和没有触发的数据。当计算后判断为触发（计算时间可以近似忽略），则认为会产生一个signal

为signal计算一个signal id，对应币对---交易所---时间戳--信号类型，作为静态插桩点，辅助后续的延迟观测

资金费率做同样的处理，作为一个静态信号，但也async的推送。固定推送signal2

支持固定阈值的模式，也是信号的输入方式，整体没有区别，整体要可以配置化，这一点体现在配置文件中。

也就是对于每个signal都遵循，维护state 触发callback的模式。

此时推送到一个channel处理。这是一个统一的事件执行queue。mpsc队列来进行处理。


queue主要负责对信号进行处理。包含在signal manager内
所有信号，维护一个state。这块写死，配置化可以后期做。
基础的信号时update 即更新某个信号的值

每个信号，都指向一个或者多个trigger的ptr。代表和信号相关的计算。

类似于，假设目前有signal a，b，c， 有一个交易信号依赖于 10 交易 01交易 001交易 则需要3个triggerx y z
a 绑定 x和z，有2个trigger
b 绑定 y和z，有2个trigger
c 绑定 xyz，3个trigger


tigger根据计算结果，判断是否需要进行交易执行，产生交易信号。这个信号同样走ipc的方式。trigger记录每个信号最后一次更新的时间，当触发的时候推送到插桩点。

订单信号对应具体需要执行的交易动作，首先需要进行风控检查才可以提交。

风控模块。风险控制。
1、trigger信号的具体内容构造成一个message的格式，币对索引idx，等等，构造成一个message。

风控检查在rust实现，对于目前的mt订单，需要检查

单个交易品种最大手数：100手 维护每个品种的count
单个交易品种本金占用：5000u 维护每个品种的本金占用
单个交易品种最大委托挂单量：3单（超过这个阈值不在报单（只记录本地的订单orderNo）） 维护当前订单的哈希表count 维护订单的state ---- 衍生到订单state的设计

订单的state对应订单在状态机的执行，状态机之后再讨论。

风控和订单预处理应该叠加，例如，改填充多少价格，用多少u。

经过预处理的订单，发送到订单执行引擎。只更新风控状态。

执行引擎是一个优先级队列，保证订单可以插队。需要带lock。这个设计是为了让对冲单可以先于市价下单执行。

无论哪种订单。执行都没有区别。只是看放在哪个交易所执行。暂时不考虑交易频率的限制。对于每个交易所的合约/现货，维护建立websocket来处理交易执行。

我需要在很多个交易所，多个ip账户进行交易。暂时不考虑那么复杂的需求。你可以简单认为，我想对每个交易所维护多个websocket连接，用于下单和处理。
但是websocket可能重启、断开等情况。重启可能是主动或者被动的重启。利用rust的一些机制。所以每个websocket不一定是完全可靠的。如果是主动重启，恢复期间应该也不可用。
有没有类似时间轮的策略，如何设计？让我提取需要的ws进行执行。考虑币安的订单支持设置new order id，bybit的reqId，可以保证我订单只执行一次。直接幂等下单即可。

订单的回报消息，认为是一个signal。
这个signal和行情的signal暂时不区分，同样的模式。
signal---triger---触发合约的对冲单子，同样是prechcek，这样极大的简化了模型实现。交易引擎不再有对冲的逻辑，而是一个单纯的下单器。

post process。当订单执行完成后输入。也是mpsc的队列，处理风控，仓位等逻辑。以及是否需要发送。post process只处理订单的回报，下单错误的回报消息也是错误。

对于对冲单，本质上也是一个信号。只是trigger非常简单，直接去下单，需要有一个建立hook的context而已。订单需要一个上下文。因为需要设计一个上下文管理系统。

整体的生命周期signal ---> trigger ---> pre_process ->trading_eng ->post_process
只有trigger触发，会有确定需要执行的交易，需要一个context存在（似乎不需要？）

现在讨论一个mt订单的执行，最简单的模式

行情 or 费率 信号
费率以分钟频率输入触发信号。
盘口行情产生signal 
每个signal 通过 时间 + 币对idx + exchange输出


trigger处理信号，检查上一次更新的状态，当资金费率信号和行情信号同时满足条件，则产生一个现货下单。包含一个trading_context


进入post进行风控检查，记录订单状态。检查仓位等情况，如果不满足，直接block丢弃信号。如果全部通过，在上下文记录state。包括延迟等数据。然后forward到交易执行的模块。

交易维护一堆的websocket，根据需求生成一个订单id，然后在多个ws上下单执行。然后直接丢弃信号。记录最后的context内容。这里需要维护一个线程安全的哈希表？不需要

本质上，只要把preprocess 和 postprocess 都放在一个tokio线程即可。这也方便之后thread pre core的改造。然后维护一个订单管理器即可。

所有的进程间通讯基于iceoryx2，比zeromq有更低的延迟，因此整个交易系统完全基于rust实现。

现在汇总以上所有思路，确定我要实现的模块。

整体进程设计是N+ 1 + 1 + 1。 N个进程用于产生signal，signal可以来自各种来源，最终的结果是产生一个signal msg。这个signal不需要基于rust，
c++的也可以，只要能通过ipc的方式，触发信号即可。
需要设计一个signal msg的format。目前只需要rust可以用就可以，产生信号。例如之前的资金费率，盘口价格等。


第一个进程是信号触发进程，signal_collector。监听iceoryx2、zmq ipc的消息。推送到一个channel。
这个rust进程，是一个基于消息事件触发的dispatcher。是一个单线程的，纯tokio。

当收到每个signal，顺序调用之前提到的trigger结构，判断是否需要产生一个交易事件。

这里的数据结构暂时用哈希表来维护signal。每个signal维护一系列的trigger。

trigger知道自己要读取哪些信号，然后进行一个聚合比较的逻辑。

当trigger触发的时候，会产生event的msg，然后通过iceoryx2推送一个新的消息，到pre-post-process进程

pre-post-process还是一个单线程的进程，负责风控和预处理。

风控目前的需求时，读取所有的交易资产列表，维护对于每个交易所单独维护。各种指标可以后续添加，目前不写死，主要是不要有race访问。

pre-post-process 维护两个channel，但是tokio select每次只响应其中的一个，不会有两个tokio

每个event会经过不同的pre-process，内容不限定。整个pre-process需要一个pipline，把一堆函数组合在一起。pipline运行过程中，需要传递一个context。

trait Pipeline<T> {
    fn pipe<U, F>(self, f: F) -> U
    where
        F: FnOnce(T) -> U;
        
    fn pipe_ref<U, F>(&self, f: F) -> U  // 支持引用
    where
        F: FnOnce(&T) -> U,
        T: Clone;
}

impl<T> Pipeline<T> for T {
    #[inline(always)]
    fn pipe<U, F>(self, f: F) -> U
    where
        F: FnOnce(T) -> U,
    {
        f(self)
    }
    
    #[inline(always)]
    fn pipe_ref<U, F>(&self, f: F) -> U
    where
        F: FnOnce(&T) -> U,
        T: Clone,
    {
        f(self)
    }
}

在经过系列的预处理之后，这个信号会变成实际的交易信号。再次用iceoryx2发送到下一个进程，即交易执行进程。

trading_eng, 交易执行进程，同样是单线程的tokio实现。这个进程的任务是纯粹的交易执行，近似是无状态的实现。
1、维护币安交易所的connection，对于spot，futures，各维护k个， k来自配置文件，表示维护k个websocket连接来执行交易。
2、启动时，启动全部的websocket，全部确认连接后，engine进入可用状态，开始处理交易。
3、iceoryx2中，接收来通过pre-process的event，根据event进行交易的执行。具体的执行流程是
4、根据event的交易所，选择，目前只有币安，跳过这一步
5、生成一个交易的id，对应交易的信息，然后在多个websocket全部尝试发送，进行交易。

核心是利用交易所机制
newClientOrderId 指定订单的 clientOrderId 值。
仅当前一个订单已成交或过期时，才会接受具有相同 clientOrderId 的新订单。

这个保护机制，应该可以选择，每次重复请求的个数，目的是为了保证交易不因为ws的网络问题影响。这个数目应该大于1，小于k
当订单发送后，这个context的生命周期结束，直接drop，无需等待回报。因为响应的时候会给出clientOrderId": "4d96324ff9d44481926157ec08158a40",然后hook上。

当ws收到反馈、例如下单因为 clientOrderId 重复失败，这些消息可以认为当前ws存活，这是正常消息。直接drop。
当ws收到反馈，订单交易成功的时候，会调用一个处理函数。这个处理函数的行为时，对消息进行parser，我会编写多个struct来处理这一点，专门用于处理交易回报的信息。
这些strruct 满足一个trait，有一个处理json的函数。

然后有一个专用的handle，找到合适的struct。

最终目的是，handle会把收到的成交回报进行处理，定义msg输入到post-process进程。这里的设计时，pre-post-process是一个单线程的进程。
原因在于两者都需要处理风控状态，这样风控数据放在这个进程可以lock-free。

当进入pre-post-process的channel，tokio select到对应的处理，同样的，通过pipline去处理，完成后续的收尾工作。这是我的整体设计流程。

一个mt策略是如何走通的
我这里的mt指的是一个套利策略，基于资费。整体的交易逻辑是：

我我维护一个产生盘口信号的进程。支持两种方式，一种维持rolling的百分位，一种固定阈值。当满足条件发送信号

资金费率信号

平仓信号 

你无需关心signal的产生，这不是这套system设计的重点。

现在的逻辑是，盘口信号和费率信号有不同的触发条件，当触发成功的时候，向信号处理进程输入，mpsc

信号处理进程查看当前变更的信号类型是什么。然后找到对应的trigger进行判断。

这里的逻辑接近于

我会有3个trigger

平仓触发、交易触发

只考虑交易，费率信号触发，表示修改下单方向，例如模型出信号 -1 （合约开空、现货开多）、模型出信号 1 （合约开多、现货开 空）

盘口则是触发是否满足交易要求。

那么考虑这个逻辑，只满足费率信号，不会触发交易。只有平仓信号和盘口信号会触发交易，考虑触发交易的情况。

盘口信号、费率信号应该绑定交易触发trigger
平仓信号绑定的应该是平仓trigger

当盘口信号更新的时候，此时触发trigger，缠身一个交易信号，生成signal id，提交到pre-post-proess的pre channel

pre的tokio seletct进行处理，首先是构造订单，这里主要是风控模块会进行检查。
1、signal产生时间和当前时间的gap时多少，和上一次交易需要保存多大的间隔
2、根据触发的trigger type预设的参数，确定需要交易量、交易方向、报价方式等基本的订单数据
3、根据配置参数，确定单手量，例如50u（按照最小下单单位调整）
4、检查单个交易品种最大手数：100手
5、检查单个交易品种本金占用：5000u
6、检查单个交易品种最大委托挂单量：3单（超过这个阈值不在报单）
7、检查signal对应的交易币对，当前的头寸要求是否满足。

包括但不限于
单个交易品种最大敞口：0.03
所有交易品种最大敞口：0.03
风控报警线：0.025

组合chain的方法参考上述描述，如果中间环节失败，drop

如果通过全部风控检查，则可以下单。通过ipc提交到交易引擎
同时，维护一个订单管理，记录这个订单的数据和状态，生成未提交，等设计一个状态机

交易引擎进行签名等工作，实现上述多发保证的逻辑，至此信号触发下单的交易结束。tigger触发，产生一个signal进入到pre-process。这个signal会把订单的状态修改为提交未生效。

接下来，由于是市价单挂单，因此挂单的价格是一个市价单，只能收到挂单确认。当收到挂单成功的回报时候，trigger触发，产生一个signal进入到pre-process。这个signal会把订单的状态修改为生效待成交。且认为以及实际上占据了仓位。需要更新仓位信息等。

接下来等待现货成交，当现货成交后，会收到一个成交回报。这个成交回报会被视为一个trigger，这个trigger是一定触发的，目的是对现货仓位进行合约对冲。

此时这个siganl进入上述pre-process的逻辑，这是分支1，会开启一个新的合约对冲市价单，且优先级设最高，防止订单排队。

同时，成交回报进入post-process，这是分支2，修改订单状态为成交。

合约对冲端的逻辑类似之前，区别在于风控。成交的时候，会归还占用的风控敞口额度，因为对冲结束。这些逻辑在post-process中处理。


帮我归档、整理上述的设计思路，给我一份整个交易系统的设计说明。当然你可以提出建议、进行评估等。































